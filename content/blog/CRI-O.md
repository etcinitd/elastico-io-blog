+++
date = "2017-11-23T14:55:02+04:30"
draft = false
title = "معرفی CRI-O نسخه 1.0"

+++


سال گذشته، پروژه کوبرنیتیز، CRI یا همان Container Runtime Interface که یک رابط پلاگین بود را معرفی کرد. این پلاگین به kubelet امکان می دهد که بتواند از کانتینر های مختلف زمان اجرا سازگار با استاندارد OCI بدون نیاز به کامپایل دوباره کوبرنیتیز استفاده کند. بر این اساس، پروژه CRI-O به منظور ایجاد یک container-runtime سبک برای کوبرنتیز ایجاد شده است.

حالا واقعا این به چه معناست ؟


CRI-O به شما امکان اجرای کانتینر ها را مستقیما از کوبرنتیز، بدون نیاز به کدی یا ابزاری اضافی فراهم می کند. تا زمانی که کانتینر، سازگار با استاندارد OCI می باشد، CRI-O می تواند آن را اجرا کند و ابزار های پیچیده و غیر اصلی را حذف کند تا به کانتینر ها این امکان را بدهد که کار خود را به بهترین شکل انجام دهند. 
قبل از معرفی CRI، کوبرنتیز به یک container-runtime مشخصی از طریق یک رابط داخلی و فرار و سطح بالا که درون kubelet پیاده سازی شده بود، وابستگی داشت. این موضوع سربار نگهداری زیادی را برای جامعه بالادستی (upstream) کوبرنتیز و همینطور ارائه دهنگان راهکار های معماری برای پلتفرم orchestration بوجود می آورد.
با وجود CRI، کوبرنتیز دیگر نیازی به دانستن container-runtime ندارد و همینطور ارائه دهندگان container-runtime مجبور به پیاده سازی امکانات و قابلیت هایی که کوبرنتیز از قبل آنها را پیاده کرده نخواهند بود. این موضوع در واقع پیروزی بزرگی برای جامعه کاربران است چرا که به پروژه ها امکان تغییرات مستقل، با حفظ سازگاری و اجرایی بودن را مهیا میکند.

برای بیشتر قسمت ها تصور ما بر آن است که کاربران کوبرنتیز (یا توزیع های آن مانند OpenShift) خیلی به container-runtime اهمیت زیادی نمی دهند. در واقع برای آنها انجام شدن کارشان مهم است و دنبال بهترین حالت ممکن نیستند. مثلا مانند اکثریت که برایشان اهمیت ندارد که ماشین مورد استفاده آنها از کدام shell استفاده می کند، حال GNU bash, Korn, Zsh یا هر shell سازگار با استاندارد POSIX باشد. مهم برای آنها، تنها اجرا کردن استاندارد اسکریپت ها و برنامه ها می باشد.

CRI-O‌: یک container-runtime سبک برای کوبرنتیز


و این آن چیزی است که CRI-O مهیا می کند. نام آن از CRI به همراه OCI یا همان (Open Container Initiative)  مشتق شده است زیرا CRI-O بطور ویژه بر روی runtime های سازگار با OCI و image کانتینر ها تمرکز کرده است.
امروزه CRI-O از runc و Clear Container runtimes پشتیبانی می کند اگرچه آن از هر runtime سازگار با OCI نیز پشتیبانی می کند. ازینرو CRI-O می تواند از هر رجیستری کانتینرها، تصاویر را دریافت (pull) کرده و مباحث مربوط به شبکه بندی (networking) را با استفاده از  Container Network Interface  یا همان (CNI) راه بیندازد و در واقع هر پلاگین شبکه که سازگار با CNI باشد، بر روی پروژه شما کار خواهد کرد.

هنگامی که کوبرنتیز نیاز به اجرای یک کانتینر دارد، با CRI-O صحبت کرده و process مربوط به CRI-O که در پشت زمینه در حال اجرا هست، برای اجرای کانتینر با runc (یا هر runtime سازگار با OCI) کار خواهد کرد. هنگامی که کوبرنتیز نیاز به متوقف ساختن یک کانتینر دارد، CRI-O آن را هندل خواهد کرد. در واقع هیچ چیز عجیبی وجود ندارد و این CRI-O می باشد که در پشت صحنه مدیریت کانتینر های لینوکس را انجام داده و خیال کاربران را برای این بخش از orchestration راحت می کند.



چیزی که CRI-O نیست!


محدوده CRI-O کار کردن با کوبرنتیز برای مدیریت و اجرای کانتینر های OCI است. و در واقع ابزاری نیست که برنامه نویس با آن روبروست. هر چند که پروژه برای عیب یابی ممکن است دارای ابزار هایی که کاربر مواجه آن می شود باشد.
برای مثال، ساخت image ها خارج از محدوده کارهای CRI-O می باشد و به ابزار های دیگری مانند دستور build داکر، Buildah و یا S2I یا همان Source-to-Image اوپن شیفت واگذار شده است. هنگامی که image ساخته شد، CRI-O از آن استفاده می کند اما ساخت image ها به سایر ابزار ها واگذار شده است.
در حالی که CRI-O شامل یک خط فرمان (CLI) می باشد، اما آن بیشتر برای تست CRI-O مهیا شده است و در واقع روشی برای مدیریت کانتینر ها در یک محیط عملیاتی نیست.

قدم بعدی


حالا که نسخه ۱.۰ CRI-O منتشر شده است، ما امیدواریم تا آن را در نسخه بعدی stable کوبرنتیز به عنوان قابلیت جدیدی ببینیم. نسخه منتشر شده ۱.۰ با سری کوبرنتیز *.۱.۷ سازگار می باشد. همینطور CRI-O نسخه release candidate1 در ۱.۸ بزودی برای کوبرنتیز *.۱.۸ منتشر خواهد شد.
